{"version":3,"sources":["CacheManager.js"],"names":["_","FileSystem","SHA1","BASE_DIR","cacheDirectory","CacheEntry","uri","options","getCacheEntry","path","exists","tmpPath","createDownloadResumable","downloadAsync","result","status","undefined","moveAsync","from","to","CacheManager","entries","deleteAsync","idempotent","makeDirectoryAsync","getInfoAsync","size","filename","substring","lastIndexOf","indexOf","length","ext","uniqueId"],"mappings":"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","sourcesContent":["// @flow\nimport * as _ from 'lodash';\nimport * as FileSystem from 'expo-file-system';\nimport SHA1 from 'crypto-js/sha1';\n\nexport type DownloadOptions = {\n  md5?: boolean,\n  headers?: { [string]: string },\n};\n\nconst BASE_DIR = `${FileSystem.cacheDirectory}expo-image-cache/`;\n\nexport class CacheEntry {\n  uri: string;\n  options: DownloadOptions;\n  path: string;\n\n  constructor(uri: string, options: DownloadOptions) {\n    this.uri = uri;\n    this.options = options;\n  }\n\n  async getPath(): Promise<?string> {\n    const { uri, options } = this;\n    const { path, exists, tmpPath } = await getCacheEntry(uri);\n    if (exists) {\n      return path;\n    }\n    const result = await FileSystem.createDownloadResumable(uri, tmpPath, options).downloadAsync();\n    // If the image download failed, we don't cache anything\n    if (result && result.status !== 200) {\n      return undefined;\n    }\n    await FileSystem.moveAsync({ from: tmpPath, to: path });\n    return path;\n  }\n}\n\nexport default class CacheManager {\n  static entries: { [uri: string]: CacheEntry } = {};\n\n  static get(uri: string, options: DownloadOptions): CacheEntry {\n    if (!CacheManager.entries[uri]) {\n      CacheManager.entries[uri] = new CacheEntry(uri, options);\n    }\n    return CacheManager.entries[uri];\n  }\n\n  static async clearCache(): Promise<void> {\n    await FileSystem.deleteAsync(BASE_DIR, { idempotent: true });\n    await FileSystem.makeDirectoryAsync(BASE_DIR);\n  }\n\n  static async getCacheSize(): Promise<number> {\n    const { size } = await FileSystem.getInfoAsync(BASE_DIR, { size: true });\n    return size;\n  }\n}\n\nconst getCacheEntry = async (uri: string): Promise<{ exists: boolean, path: string, tmpPath: string }> => {\n  const filename = uri.substring(uri.lastIndexOf('/'), uri.indexOf('?') === -1 ? uri.length : uri.indexOf('?'));\n  const ext = filename.indexOf('.') === -1 ? '.jpg' : filename.substring(filename.lastIndexOf('.'));\n  const path = `${BASE_DIR}${SHA1(uri)}${ext}`;\n  const tmpPath = `${BASE_DIR}${SHA1(uri)}-${_.uniqueId()}${ext}`;\n  // TODO: maybe we don't have to do this every time\n  try {\n    await FileSystem.makeDirectoryAsync(BASE_DIR);\n  } catch (e) {\n    // do nothing\n  }\n  const { exists } = await FileSystem.getInfoAsync(path);\n  return { exists, path, tmpPath };\n};\n"]}