{"version":3,"sources":["CacheManager.ts"],"names":["FileSystem","_","SHA1","BASE_DIR","cacheDirectory","CacheEntry","uri","options","getCacheEntry","path","exists","tmpPath","createDownloadResumable","downloadAsync","result","status","undefined","moveAsync","from","to","CacheManager","entries","deleteAsync","idempotent","makeDirectoryAsync","getInfoAsync","Error","size","filename","substring","lastIndexOf","indexOf","length","ext","uniqueId"],"mappings":"4LACA,MAAO,GAAKA,CAAAA,UAAZ,KAA4B,kBAA5B,CACA,MAAO,GAAKC,CAAAA,CAAZ,KAAmB,QAAnB,CACA,MAAOC,CAAAA,IAAP,KAAiB,gBAAjB,CAOA,GAAMC,CAAAA,QAAQ,CAAMH,UAAU,CAACI,cAAjB,oBAAd,CAEA,UAAaC,CAAAA,UAAb,YAIE,oBAAYC,GAAZ,CAAyBC,OAAzB,CAAmD,kCACjD,KAAKD,GAAL,CAAWA,GAAX,CACA,KAAKC,OAAL,CAAeA,OAAf,CACD,CAPH,kOAUYD,GAVZ,CAU6B,IAV7B,CAUYA,GAVZ,CAUiBC,OAVjB,CAU6B,IAV7B,CAUiBA,OAVjB,kDAW4CC,aAAa,CAACF,GAAD,CAXzD,4BAWYG,IAXZ,MAWYA,IAXZ,CAWkBC,MAXlB,MAWkBA,MAXlB,CAW0BC,OAX1B,MAW0BA,OAX1B,KAYQD,MAZR,yDAYuBD,IAZvB,2DAcyBT,UAAU,CAC5BY,uBADkB,CACMN,GADN,CACWK,OADX,CACoBJ,OADpB,EAElBM,aAFkB,EAdzB,UAcUC,MAdV,oBAmBQA,MAAM,EAAIA,MAAM,CAACC,MAAP,GAAkB,GAnBpC,2DAmBgDC,SAnBhD,4DAqBUhB,UAAU,CAACiB,SAAX,CAAqB,CAAEC,IAAI,CAAEP,OAAR,CAAiBQ,EAAE,CAAEV,IAArB,CAArB,CArBV,0CAsBWA,IAtBX,qF,GA0BMW,CAAAA,Y,sIAGOd,G,CAAaC,O,CAAsC,CAC5D,GAAI,CAACa,YAAY,CAACC,OAAb,CAAqBf,GAArB,CAAL,CAAgC,CAC9Bc,YAAY,CAACC,OAAb,CAAqBf,GAArB,EAA4B,GAAID,CAAAA,UAAJ,CAAeC,GAAf,CAAoBC,OAApB,CAA5B,CACD,CAED,MAAOa,CAAAA,YAAY,CAACC,OAAb,CAAqBf,GAArB,CAAP,CACD,C,yNAGON,UAAU,CAACsB,WAAX,CAAuBnB,QAAvB,CAAiC,CAAEoB,UAAU,CAAE,IAAd,CAAjC,C,2DACAvB,UAAU,CAACwB,kBAAX,CAA8BrB,QAA9B,C,2RAIeH,UAAU,CAACyB,YAAX,CAAwBtB,QAAxB,C,SAAfW,M,mBACDA,MAAM,CAACJ,M,+BAAc,IAAIgB,CAAAA,KAAJ,CAAavB,QAAb,c,yCAEnBW,MAAM,CAACa,I,6EApBZP,Y,CACGC,O,CAAyC,E,CAuBlD,GAAMb,CAAAA,aAAa,CAAG,QAAhBA,CAAAA,aAAgB,CAAOF,GAAP,uKACdsB,QADc,CACHtB,GAAG,CAACuB,SAAJ,CACfvB,GAAG,CAACwB,WAAJ,CAAgB,GAAhB,CADe,CAEfxB,GAAG,CAACyB,OAAJ,CAAY,GAAZ,EAAmB,CAAnB,CAAuBzB,GAAG,CAAC0B,MAA3B,CAAoC1B,GAAG,CAACyB,OAAJ,CAAY,GAAZ,CAFrB,CADG,CAKdE,GALc,CAKRL,QAAQ,CAACG,OAAT,CAAiB,GAAjB,EAAwB,CAAxB,CAA4B,MAA5B,CACVH,QAAQ,CAACC,SAAT,CAAmBD,QAAQ,CAACE,WAAT,CAAqB,GAArB,CAAnB,CANkB,CAQhBpB,MARgB,CAQP,KARO,CASdD,IATc,IASJN,QATI,CASOD,IAAI,CAACI,GAAD,CATX,CASmB2B,GATnB,CAUdtB,OAVc,IAUDR,QAVC,CAUUD,IAAI,CAACI,GAAD,CAVd,KAUuBL,CAAC,CAACiC,QAAF,EAVvB,CAUsCD,GAVtC,oEAcZjC,UAAU,CAACwB,kBAAX,CAA8BrB,QAA9B,CAdY,4DAeEH,UAAU,CAACyB,YAAX,CAAwBhB,IAAxB,CAfF,+BAefC,MAfe,OAefA,MAfe,+HAoBb,CACLA,MAAM,CAANA,MADK,CAELD,IAAI,CAAJA,IAFK,CAGLE,OAAO,CAAPA,OAHK,CApBa,qEAAtB,CA2BA,cAAeS,CAAAA,YAAf","sourcesContent":["// @flow\nimport * as FileSystem from 'expo-file-system';\nimport * as _ from 'lodash';\nimport SHA1 from 'crypto-js/sha1';\n\nexport interface DownloadOptions {\n  md5?: boolean;\n  headers?: { [name: string]: string };\n}\n\nconst BASE_DIR = `${FileSystem.cacheDirectory}expo-image-cache/`;\n\nexport class CacheEntry {\n  uri: string;\n  options: DownloadOptions;\n\n  constructor(uri: string, options: DownloadOptions) {\n    this.uri = uri;\n    this.options = options;\n  }\n\n  async getPath(): Promise<string | undefined> {\n    const { uri, options } = this;\n    const { path, exists, tmpPath } = await getCacheEntry(uri);\n    if (exists) return path;\n\n    const result = await FileSystem\n      .createDownloadResumable(uri, tmpPath, options)\n      .downloadAsync();\n\n    // If the image download failed, we don't cache anything\n    if (result && result.status !== 200) return undefined;\n\n    await FileSystem.moveAsync({ from: tmpPath, to: path });\n    return path;\n  }\n}\n\nclass CacheManager {\n  static entries: { [uri: string]: CacheEntry } = {};\n\n  static get(uri: string, options: DownloadOptions): CacheEntry {\n    if (!CacheManager.entries[uri]) {\n      CacheManager.entries[uri] = new CacheEntry(uri, options);\n    }\n\n    return CacheManager.entries[uri];\n  }\n\n  static async clearCache(): Promise<void> {\n    await FileSystem.deleteAsync(BASE_DIR, { idempotent: true });\n    await FileSystem.makeDirectoryAsync(BASE_DIR);\n  }\n\n  static async getCacheSize(): Promise<number> {\n    const result = await FileSystem.getInfoAsync(BASE_DIR);\n    if (!result.exists) throw new Error(`${BASE_DIR} not found`);\n\n    return result.size;\n  }\n}\n\nconst getCacheEntry = async (uri: string): Promise<{ exists: boolean; path: string; tmpPath: string }> => {\n  const filename = uri.substring(\n    uri.lastIndexOf('/'),\n    uri.indexOf('?') < 0 ? uri.length : uri.indexOf('?'),\n  );\n  const ext = filename.indexOf('.') < 0 ? '.jpg' :\n    filename.substring(filename.lastIndexOf('.'));\n\n  let exists = false;\n  const path = `${BASE_DIR}${SHA1(uri)}${ext}`;\n  const tmpPath = `${BASE_DIR}${SHA1(uri)}-${_.uniqueId()}${ext}`;\n\n  // TODO: maybe we don't have to do this every time\n  try {\n    await FileSystem.makeDirectoryAsync(BASE_DIR);\n    ({ exists } = await FileSystem.getInfoAsync(path));\n  } catch (e) {\n    // do nothing\n  }\n\n  return {\n    exists,\n    path,\n    tmpPath,\n  };\n};\n\nexport default CacheManager;\n"]}